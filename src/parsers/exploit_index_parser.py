from typing import List, Dict, Optional, Tuple
import re
from pathlib import Path
from datetime import datetime
from .base_parser import BaseParser

class ExploitIndexParser(BaseParser):
    """
    Парсер для индексных файлов с эксплойтами
    """
    
    # Паттерны для определения типов уязвимостей
    VULNERABILITY_PATTERNS = {
        'xss': r'(?i)(cross.*site.*script|xss|reflected.*xss|stored.*xss|dom.*xss)',
        'rce': r'(?i)(remote.*code.*exec|rce|command.*exec|remote.*exec|arbitrary.*code)',
        'sqli': r'(?i)(sql.*inject|sqli|sql.*vuln|blind.*sql)',
        'upload': r'(?i)(unrestricted.*file.*upload|arbitrary.*file.*upload|malicious.*upload)',
        'traversal': r'(?i)(path.*traversal|directory.*traversal|lfi|rfi|local.*file.*inclusion)',
        'bypass': r'(?i)(auth.*bypass|authentication.*bypass|login.*bypass|admin.*bypass)',
        'overflow': r'(?i)(buffer.*overflow|stack.*overflow|heap.*overflow|integer.*overflow)',
        'injection': r'(?i)(command.*inject|code.*inject|shell.*inject|os.*command)',
        'csrf': r'(?i)(cross.*site.*request.*forgery|csrf|xsrf)',
        'ssrf': r'(?i)(server.*side.*request.*forgery|ssrf)',
        'xxe': r'(?i)(xml.*external.*entity|xxe)',
        'deserialization': r'(?i)(insecure.*deserialization|unsafe.*deserialization)',
        'dos': r'(?i)(denial.*of.*service|dos|crash|resource.*exhaustion)',
        'info_disclosure': r'(?i)(information.*disclosure|info.*leak|data.*leak)',
    }
    
    # Расширенные паттерны для ПО
    SOFTWARE_PATTERNS = {
        'cms': {
            'wordpress': r'(?i)(wordpress|wp-admin|wp-content)',
            'joomla': r'(?i)(joomla|com_content|com_users)',
            'drupal': r'(?i)(drupal|node/add|user/register)',
            'magento': r'(?i)(magento|mage_core)',
            'opencart': r'(?i)(opencart|index\.php\?route)',
            'prestashop': r'(?i)(prestashop|ps_|_ps)',
            'seeddms': r'(?i)(seeddms|letodms)',
            'cpms': r'(?i)(cpms|content.*management)',
            'crest': r'(?i)(crest.*engine|crestengine)',
            'moodle': r'(?i)(moodle|learn|lms)'
        },
        'framework': {
            'laravel': r'(?i)(laravel|artisan|blade)',
            'symfony': r'(?i)(symfony|bundles|twig)',
            'django': r'(?i)(django|wsgi|urls\.py)',
            'flask': r'(?i)(flask|werkzeug|jinja2)',
            'spring': r'(?i)(spring boot|springframework)',
            'struts': r'(?i)(struts|struts2|ognl)',
            'rails': r'(?i)(rails|activerecord|rake)',
            'zend': r'(?i)(zend|zf|zf2)',
            'yii': r'(?i)(yii|yii2)',
            'codeigniter': r'(?i)(codeigniter|ci_)'
        },
        'database': {
            'mysql': r'(?i)(mysql|mysqli|mariadb)',
            'postgresql': r'(?i)(postgresql|psql|pg_)',
            'oracle': r'(?i)(oracle|plsql|oci)',
            'mongodb': r'(?i)(mongodb|mongo|mongoose)',
            'elasticsearch': r'(?i)(elasticsearch|elastic|kibana)',
            'redis': r'(?i)(redis|redis-cli)',
            'sqlite': r'(?i)(sqlite|sqlite3)',
            'mssql': r'(?i)(mssql|sqlserver)'
        },
        'server': {
            'apache': r'(?i)(apache2?|httpd\.conf)',
            'nginx': r'(?i)(nginx|nginx\.conf)',
            'iis': r'(?i)(iis|asp\.net|web\.config)',
            'tomcat': r'(?i)(tomcat|catalina|jsp)',
            'weblogic': r'(?i)(weblogic|wls|wlst)',
            'websphere': r'(?i)(websphere|was|ibm)',
            'lighttpd': r'(?i)(lighttpd|lighty)',
            'cherokee': r'(?i)(cherokee)'
        },
        'language': {
            'php': r'(?i)(php[0-9]?|\.php|php\.ini)',
            'python': r'(?i)(python[23]?|\.py|pip)',
            'java': r'(?i)(java|\.jar|\.war)',
            'javascript': r'(?i)(javascript|node\.js|\.js)',
            'ruby': r'(?i)(ruby|rails|\.rb)',
            'perl': r'(?i)(perl|\.pl|cpan)',
            'go': r'(?i)(golang|\.go)',
            'rust': r'(?i)(rust|cargo|\.rs)'
        },
        'browser': {
            'firefox': r'(?i)(firefox|mozilla)',
            'chrome': r'(?i)(chrome|chromium)',
            'safari': r'(?i)(safari|webkit)',
            'edge': r'(?i)(edge|msedge)',
            'ie': r'(?i)(internet.*explorer|ie\d+)'
        },
        'application': {
            'adobe': r'(?i)(adobe|acrobat|reader)',
            'office': r'(?i)(microsoft.*office|word|excel|powerpoint)',
            'outlook': r'(?i)(outlook|exchange)',
            'git': r'(?i)(git|github|gitlab)',
            'docker': r'(?i)(docker|container|dockerfile)',
            'jenkins': r'(?i)(jenkins|hudson)',
            'jira': r'(?i)(jira|atlassian)',
            'wordpress_plugin': r'(?i)(wp-content/plugins/[^/]+)',
            'wordpress_theme': r'(?i)(wp-content/themes/[^/]+)'
        }
    }
    
    # Улучшенные паттерны для версий
    VERSION_PATTERNS = [
        # Стандартные версии
        r'(?i)version\s*([\d.]+(?:-[a-z0-9]+)?)',      # version 1.2.3
        r'(?i)v\.?\s*([\d.]+(?:-[a-z0-9]+)?)',         # v1.2.3 или v.1.2.3
        
        # Версии с префиксом продукта
        r'(?i)([a-z]+)[- _](?:version|v\.?)\s*([\d.]+(?:-[a-z0-9]+)?)',  # php version 7.4
        
        # Версии в скобках
        r'(?i)\((version|v\.?)?\s*([\d.]+(?:-[a-z0-9]+)?)\)',  # (version 1.2.3)
        
        # Версии после продукта
        r'(?i)([a-z]+(?:\s+[a-z]+)?)\s+([\d.]+(?:-[a-z0-9]+)?)',  # PHP 7.4.1
        
        # Версии в названии файла
        r'(?i)[-_]v?([\d.]+(?:-[a-z0-9]+)?)\.',  # example-1.2.3.txt
        
        # Специфичные форматы
        r'(?i)(?:release|build)\s*([\d.]+(?:-[a-z0-9]+)?)',  # release 1.2.3
        r'(?i)(?:update|patch)\s*([\d.]+(?:-[a-z0-9]+)?)',   # update 1.2.3
    ]
    
    def __init__(self):
        super().__init__()
        self.source_path = None
        
    def parse_file(self, file_path: str) -> List[Dict]:
        """
        Парсинг индексного файла
        """
        self.source_path = Path(file_path)
        results = []
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if not line:
                        continue
                        
                    # Определение формата и парсинг
                    format_type = self._detect_format(line)
                    if format_type == 'cxsecurity':
                        entry = self._parse_cxsecurity(line)
                    elif format_type == 'sploitus':
                        entry = self._parse_sploitus(line)
                    elif format_type == 'packetstorm':
                        entry = self._parse_packetstorm(line)
                    else:
                        self.errors.append(f"Неизвестный формат: {line}")
                        continue
                        
                    if entry:
                        results.append(entry)
                        
            return results
            
        except Exception as e:
            self.errors.append(f"Ошибка при чтении файла {file_path}: {str(e)}")
            return []
            
    def _detect_format(self, line: str) -> str:
        """Определение формата строки"""
        if re.match(r'WLB-\d+\.txt:', line):
            return 'cxsecurity'
        elif 'CVE-' in line and '.zip:' in line:
            return 'sploitus'
        elif ';' in line and re.match(r'\d{4}-\d{2}-\d{2}', line.split(';')[0].split(':')[1].strip()):
            return 'packetstorm'
        return 'unknown'
        
    def _parse_cxsecurity(self, line: str) -> Optional[Dict]:
        """Парсинг формата CXSecurity"""
        try:
            filename, description = line.split(':', 1)
            
            # Извлечение ID
            wlb_id = re.match(r'(WLB-\d+)', filename)
            if not wlb_id:
                return None
                
            # Анализ описания
            vuln_info = self._analyze_description(description)
            
            return {
                'filename': filename.strip(),
                'description': description.strip(),
                'source_index': str(self.source_path),
                'metadata': {
                    'id': wlb_id.group(1),
                    'source': 'cxsecurity',
                    'type': vuln_info['type'],
                    'tags': vuln_info['tags'],
                    'cve': vuln_info['cve'],
                    'software': vuln_info['software']
                }
            }
        except Exception as e:
            self.errors.append(f"Ошибка при парсинге CXSecurity: {str(e)}")
            return None
            
    def _parse_sploitus(self, line: str) -> Optional[Dict]:
        """Парсинг формата Sploitus"""
        try:
            filename, info = line.split(':', 1)
            parts = info.strip().split(' ', 2)
            if len(parts) < 3:
                return None
                
            author, date, description = parts
            
            # Извлечение CVE из имени файла и описания
            cve_ids = set()
            file_cve = re.search(r'(CVE-\d{4}-\d+)', filename)
            if file_cve:
                cve_ids.add(file_cve.group(1))
            
            # Анализ описания
            vuln_info = self._analyze_description(description)
            cve_ids.update(vuln_info['cve'])
            
            return {
                'filename': filename.strip(),
                'description': description.strip(),
                'source_index': str(self.source_path),
                'metadata': {
                    'id': list(cve_ids)[0] if cve_ids else None,
                    'source': 'sploitus',
                    'author': author,
                    'date': date,
                    'type': vuln_info['type'],
                    'tags': vuln_info['tags'],
                    'cve': list(cve_ids),
                    'software': vuln_info['software']
                }
            }
        except Exception as e:
            self.errors.append(f"Ошибка при парсинге Sploitus: {str(e)}")
            return None
            
    def _parse_packetstorm(self, line: str) -> Optional[Dict]:
        """Парсинг формата PacketStorm"""
        try:
            name_part, rest = line.split(':', 1)
            date, description = rest.split(';', 1)
            
            # Анализ описания
            vuln_info = self._analyze_description(description)
            
            return {
                'filename': name_part.strip(),
                'description': description.strip(),
                'source_index': str(self.source_path),
                'metadata': {
                    'source': 'packetstorm',
                    'date': date.strip(),
                    'type': vuln_info['type'],
                    'tags': vuln_info['tags'],
                    'cve': vuln_info['cve'],
                    'software': vuln_info['software']
                }
            }
        except Exception as e:
            self.errors.append(f"Ошибка при парсинге PacketStorm: {str(e)}")
            return None
            
    def _find_version_for_software(self, text: str, software: str) -> Optional[str]:
        """
        Поиск версии для конкретного ПО с учетом контекста
        """
        # Нормализация имени ПО
        sw_lower = software.lower()
        text_lower = text.lower()
        
        # Поиск всех упоминаний ПО
        sw_positions = []
        for sw_variant in [sw_lower, sw_lower.replace(' ', ''), sw_lower.replace('-', '')]:
            sw_positions.extend([m.start() for m in re.finditer(sw_variant, text_lower)])
            
        if not sw_positions:
            return None
            
        # Поиск версий рядом с каждым упоминанием
        for pos in sw_positions:
            # Проверяем текст до и после упоминания ПО
            before = text[max(0, pos-50):pos]
            after = text[pos:min(len(text), pos+50)]
            
            # Сначала ищем версию после упоминания
            for pattern in self.VERSION_PATTERNS:
                version_match = re.search(pattern, after)
                if version_match:
                    version = version_match.group(1) if len(version_match.groups()) == 1 else version_match.group(2)
                    if self._is_valid_version(version):
                        # Проверяем, что версия действительно относится к этому ПО
                        context = text[max(0, pos-30):min(len(text), pos+30)]
                        if self._version_belongs_to_software(context, sw_lower, version):
                            return version
                            
            # Затем ищем версию до упоминания
            for pattern in self.VERSION_PATTERNS:
                version_match = re.search(pattern, before)
                if version_match:
                    version = version_match.group(1) if len(version_match.groups()) == 1 else version_match.group(2)
                    if self._is_valid_version(version):
                        context = text[max(0, pos-30):min(len(text), pos+30)]
                        if self._version_belongs_to_software(context, sw_lower, version):
                            return version
                            
        return None
        
    def _version_belongs_to_software(self, context: str, software: str, version: str) -> bool:
        """
        Проверяет, относится ли найденная версия к указанному ПО
        """
        # Если между ПО и версией слишком большое расстояние, это подозрительно
        if abs(context.lower().find(software) - context.lower().find(version)) > 20:
            return False
            
        # Проверяем, нет ли между ПО и версией упоминания другого ПО
        for category in self.SOFTWARE_PATTERNS.values():
            for other_sw in category.keys():
                if other_sw != software and other_sw in context.lower():
                    # Если другое ПО находится между нашим ПО и версией
                    sw_pos = context.lower().find(software)
                    ver_pos = context.lower().find(version)
                    other_pos = context.lower().find(other_sw)
                    
                    if min(sw_pos, ver_pos) < other_pos < max(sw_pos, ver_pos):
                        return False
                        
        return True
        
    def _is_valid_version(self, version: str) -> bool:
        """
        Расширенная проверка валидности версии
        """
        # Базовая проверка формата
        if not re.match(r'^[\d.]+(?:-[a-z0-9]+)?$', version):
            return False
            
        # Проверка компонентов версии
        parts = version.split('.')
        
        # Должна быть хотя бы одна цифра
        if not any(part.isdigit() for part in parts):
            return False
            
        # Проверка диапазонов для компонентов
        for part in parts:
            if part.isdigit():
                num = int(part)
                # Отфильтровываем нереалистичные версии
                if num > 100:  # Вряд ли будет версия 101.0
                    return False
                    
        return True
        
    def _analyze_description(self, text: str) -> Dict:
        """
        Полный анализ описания
        """
        # Определение типа уязвимости
        vuln_type = 'other'
        vuln_tags = set()
        
        # Поиск типов уязвимостей
        for v_type, pattern in self.VULNERABILITY_PATTERNS.items():
            if re.search(pattern, text):
                if vuln_type == 'other':  # Первый найденный тип становится основным
                    vuln_type = v_type
                vuln_tags.add(v_type)
                
        # Извлечение информации о ПО
        software_info = self._extract_software_info(text)
        
        # Добавление тегов из информации о ПО
        for category, software in software_info.items():
            if isinstance(software, dict):
                for sw_name in software.keys():
                    vuln_tags.add(sw_name)
                    
        # Поиск CVE
        cve_ids = re.findall(r'CVE-\d{4}-\d{4,7}', text)
        
        # Добавление специфичных тегов
        if 'poc' in text.lower() or 'proof of concept' in text.lower():
            vuln_tags.add('poc')
        if 'exploit' in text.lower():
            vuln_tags.add('exploit')
            
        return {
            'type': vuln_type,
            'tags': list(vuln_tags),
            'cve': list(set(cve_ids)),
            'software': software_info
        }
        
    def _extract_software_info(self, text: str) -> Dict:
        """
        Извлечение информации о ПО и версиях
        """
        software_info = {}
        found_versions = []
        
        # Поиск упоминаний ПО
        for category, software_types in self.SOFTWARE_PATTERNS.items():
            matches = {}
            for sw_name, pattern in software_types.items():
                if re.search(pattern, text):
                    version = self._find_version_for_software(text, sw_name)
                    if version:
                        matches[sw_name] = version
                    else:
                        matches[sw_name] = None
            if matches:
                software_info[category] = matches
                
        # Поиск версий, не привязанных к конкретному ПО
        for pattern in self.VERSION_PATTERNS:
            versions = re.finditer(pattern, text)
            for v in versions:
                version = v.group(1) if len(v.groups()) == 1 else v.group(2)
                if self._is_valid_version(version):
                    found_versions.append(version)
                    
        if found_versions:
            software_info['versions'] = list(set(found_versions))
            
        return software_info