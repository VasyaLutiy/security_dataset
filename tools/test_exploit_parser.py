#!/usr/bin/env python3
import sys
import json
from pathlib import Path
import logging
from collections import Counter

# Добавляем путь к корневой директории проекта в PYTHONPATH
project_root = Path(__file__).parent.parent
sys.path.append(str(project_root))

from src.parsers.exploit_index_parser import ExploitIndexParser

# Настройка логирования
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def test_parser(file_path: str):
    """
    Тестирование парсера на одном файле
    
    Args:
        file_path: путь к индексному файлу
    """
    try:
        parser = ExploitIndexParser()
        entries = parser.parse_file(file_path)
        
        logger.info(f"Обработка файла: {file_path}")
        logger.info(f"Найдено записей: {len(entries)}")
        
        # Статистика
        formats = Counter()
        types = Counter()
        tags = Counter()
        software_categories = Counter()
        software_names = Counter()
        versions = []
        cves = 0
        
        # Анализ результатов
        for entry in entries:
            formats[entry['metadata']['source']] += 1
            types[entry['metadata']['type']] += 1
            tags.update(entry['metadata']['tags'])
            cves += len(entry['metadata'].get('cve', []))
            
            # Анализ информации о ПО
            software_info = entry['metadata'].get('software', {})
            for category, sw_data in software_info.items():
                if category != 'versions':
                    software_categories[category] += 1
                    if isinstance(sw_data, dict):
                        for name, version in sw_data.items():
                            software_names[name] += 1
                            if version:
                                versions.append(f"{name} {version}")
                                
        # Вывод статистики
        print("\nСтатистика обработки:")
        print(f"Всего записей: {len(entries)}")
        print(f"Найдено CVE: {cves}")
        
        print("\nРаспределение по форматам:")
        for fmt, count in formats.most_common():
            print(f"- {fmt}: {count}")
            
        print("\nТипы уязвимостей:")
        for vuln_type, count in types.most_common():
            print(f"- {vuln_type}: {count}")
            
        print("\nПопулярные теги:")
        for tag, count in tags.most_common(10):
            print(f"- {tag}: {count}")
            
        print("\nКатегории ПО:")
        for category, count in software_categories.most_common():
            print(f"- {category}: {count}")
            
        print("\nПопулярное ПО:")
        for name, count in software_names.most_common(10):
            print(f"- {name}: {count}")
            
        if versions:
            print("\nПримеры версий ПО:")
            for version in versions[:10]:
                print(f"- {version}")
            
        # Поиск интересных примеров
        print("\nПримеры записей с информацией о ПО:")
        examples_shown = 0
        for entry in entries:
            if examples_shown >= 3:
                break
                
            software_info = entry['metadata'].get('software', {})
            if software_info and any(isinstance(v, dict) and any(ver for ver in v.values()) 
                                   for k, v in software_info.items()):
                print(f"\nЗапись {examples_shown + 1}:")
                print(json.dumps(entry, indent=2, ensure_ascii=False))
                examples_shown += 1
                
        # Вывод ошибок
        if parser.errors:
            print("\nОшибки при обработке:")
            for error in parser.errors:
                print(f"- {error}")
                
    except Exception as e:
        logger.error(f"Ошибка при тестировании парсера: {e}")
        sys.exit(1)

def main():
    if len(sys.argv) != 2:
        print("Использование: python test_exploit_parser.py <путь к index_.txt>")
        sys.exit(1)
        
    test_parser(sys.argv[1])

if __name__ == "__main__":
    main()